/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_path.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/16 15:30:16 by shiori            #+#    #+#             */
/*   Updated: 2024/08/04 17:36:47 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	is_valid_move(t_game *game, int x, int y, char **visited)
{
	return (y >= 0 && y < game->map->y && x >= 0 && x < game->map->x
		&& game->map->data[y][x] != '1' && visited[y][x] == '0');
}

int	check_reachable_exit(t_game *game, int x, int y, char **visited)
{
	if (game->map->data[y][x] == 'E')
		return (1);
	visited[y][x] = '1';
	if (is_valid_move(game, x + 1, y, visited) && check_reachable_exit(game, x
			+ 1, y, visited))
		return (1);
	if (is_valid_move(game, x - 1, y, visited) && check_reachable_exit(game, x
			- 1, y, visited))
		return (1);
	if (is_valid_move(game, x, y + 1, visited) && check_reachable_exit(game, x,
			y + 1, visited))
		return (1);
	if (is_valid_move(game, x, y - 1, visited) && check_reachable_exit(game, x,
			y - 1, visited))
		return (1);
	return (0);
}

int	count_reachable_collectibles(t_game *game, int x, int y, char **visited)
{
	int	count;

	count = 0;
	if (!is_valid_move(game, x, y, visited))
		return (0);
	visited[y][x] = '1';
	if (game->map->data[y][x] == 'C')
		count++;
	count += count_reachable_collectibles(game, x + 1, y, visited);
	count += count_reachable_collectibles(game, x - 1, y, visited);
	count += count_reachable_collectibles(game, x, y + 1, visited);
	count += count_reachable_collectibles(game, x, y - 1, visited);
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   game.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/06 17:35:40 by shiori            #+#    #+#             */
/*   Updated: 2024/08/04 17:30:11 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	load_images(t_game *game)
{
	int	width;
	int	height;

	game->image_wall = mlx_xpm_file_to_image(game->mlx_ptr, WALL_XPM, &width,
			&height);
	game->image_empty = mlx_xpm_file_to_image(game->mlx_ptr, EMPTY_XPM, &width,
			&height);
	game->image_player = mlx_xpm_file_to_image(game->mlx_ptr, PLAYER_XPM,
			&width, &height);
	game->image_collectible = mlx_xpm_file_to_image(game->mlx_ptr,
			COLLECTIBLE_XPM, &width, &height);
	game->image_exit = mlx_xpm_file_to_image(game->mlx_ptr, EXIT_XPM, &width,
			&height);
	if (!game->image_wall || !game->image_empty || !game->image_player
		|| !game->image_collectible || !game->image_exit)
	{
		ft_putstr_fd("Error\nFailed to load textures\n", 2);
		free_resources(game);
		exit(EXIT_FAILURE);
	}
}

void	init_game(t_game *game)
{
	int	x;
	int	y;

	load_images(game);
	game->collected = 0;
	game->collectibles = 0;
	game->move_count = 0;
	y = -1;
	while (++y < game->map->y)
	{
		x = -1;
		while (++x < game->map->x)
		{
			if (game->map->data[y][x] == 'P')
			{
				game->player_x = x;
				game->player_y = y;
			}
			else if (game->map->data[y][x] == 'C')
			{
				game->collectibles++;
			}
		}
	}
}

void	ft_move(t_game *game, int new_x, int new_y)
{
	if (game->map->data[new_y][new_x] == '1')
		return ;
	if (game->map->data[new_y][new_x] == 'C')
	{
		game->collected++;
		game->map->data[new_y][new_x] = '0';
	}
	if (game->map->data[new_y][new_x] == 'E')
	{
		if (game->collected == game->collectibles)
			winner(game);
		else
			ft_exit(game);
		return ;
	}
	game->map->data[game->player_y][game->player_x] = '0';
	game->player_x = new_x;
	game->player_y = new_y;
	game->map->data[new_y][new_x] = 'P';
	game->move_count++;
	write(1, "Moves: ", 7);
	ft_putnbr_fd(game->move_count, 1);
	write(1, "\n", 1);
	render_map(game);
}

int	handle_keypress(int keycode, t_game *game)
{
	int	new_x;
	int	new_y;

	new_x = game->player_x;
	new_y = game->player_y;
	if (keycode == KEY_ESC)
		ft_exit(game);
	else if (keycode == KEY_W || keycode == KEY_UP)
		new_y--;
	else if (keycode == KEY_A || keycode == KEY_LEFT)
		new_x--;
	else if (keycode == KEY_S || keycode == KEY_DOWN)
		new_y++;
	else if (keycode == KEY_D || keycode == KEY_RIGHT)
		new_x++;
	if (new_x != game->player_x || new_y != game->player_y)
		ft_move(game, new_x, new_y);
	return (0);
}

void	render_map(t_game *game)
{
	int		x;
	int		y;
	void	*image;

	mlx_clear_window(game->mlx_ptr, game->win_ptr);
	y = -1;
	while (++y < game->map->y)
	{
		x = -1;
		while (++x < game->map->x)
		{
			if (game->map->data[y][x] == '1')
				image = game->image_wall;
			else if (game->map->data[y][x] == '0')
				image = game->image_empty;
			else if (game->map->data[y][x] == 'C')
				image = game->image_collectible;
			else if (game->map->data[y][x] == 'E')
				image = game->image_exit;
			else if (game->map->data[y][x] == 'P')
				image = game->image_player;
			mlx_put_image_to_window(game->mlx_ptr, game->win_ptr, image, x
				* TILE_SIZE, y * TILE_SIZE);
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/06 20:51:47 by shiori            #+#    #+#             */
/*   Updated: 2024/08/04 17:39:38 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	handle_error(t_game *game, char *msg, int num)
{
	if (msg)
	{
		ft_putstr_fd("Error\n", 2);
		ft_putstr_fd(msg, 2);
	}
	if (num)
	{
		free_resources(game);
	}
	exit(EXIT_FAILURE);
}

int	ft_exit(t_game *game)
{
	ft_printf("-----------------------------------------------\n");
	ft_printf("              Game Over :(                   \n");
	ft_printf("        You gave up on the mission.          \n");
	ft_printf("   Is the game too challenging for you?      \n");
	ft_printf("        Don't worry, you can try again!      \n");
	ft_printf("                                             \n");
	ft_printf("   Total moves made: %d                       \n",
		game->move_count);
	ft_printf("   Collectibles gathered: %d/%d                \n",
		game->collected, game->collectibles);
	ft_printf("-----------------------------------------------\n");
	free_resources(game);
	exit(EXIT_SUCCESS);
}

void	winner(t_game *game)
{
	ft_printf("-----------------------------------------------\n");
	ft_printf("    ðŸŽ‰ðŸŽ‰ðŸŽ‰  Congratulations!!!!  ðŸŽ‰ðŸŽ‰ðŸŽ‰     \n");
	ft_printf("    You found all collectibles and exit.     \n");
	ft_printf("        âœ“âœ“âœ“âœ“âœ“âœ“âœ“âœ“ You won! âœ“âœ“âœ“âœ“âœ“âœ“âœ“âœ“           \n");
	ft_printf("     Is %d moves the best you can do?         \n",
		game->move_count);
	ft_printf("-----------------------------------------------\n");
	free_resources(game);
	exit(EXIT_SUCCESS);
}

int	setup_game(t_game *game, char *filename)
{
	ft_memset(game, 0, sizeof(t_game));
	game->mlx_ptr = mlx_init();
	if (!game->mlx_ptr)
		return (1);
	game->map = malloc(sizeof(t_map));
	if (!game->map)
		return (1);
	if (check_file_name(filename))
		return (free_resources(game), 1);
	if (count_map_size(filename, game))
		return (free_resources(game), 1);
	game->map->data = (char **)malloc((game->map->y + 1) * sizeof(char *));
	if (!game->map->data)
		return (free_resources(game), 1);
	create_map(game, filename);
	game->win_ptr = mlx_new_window(game->mlx_ptr, game->map->x * TILE_SIZE,
			game->map->y * TILE_SIZE, "So Long");
	if (!game->win_ptr)
		return (free_resources(game), 1);
	return (0);
}

int	main(int argc, char **argv)
{
	t_game	game;

	if (argc != 2)
		handle_error(NULL, "Usage: ./so_long <map.filename>\n", 0);
	if (setup_game(&game, argv[1]))
		handle_error(&game, "Failed to setup game\n", 1);
	init_game(&game);
	if (!is_valid_path(&game))
		handle_error(&game, "No valid path in map\n", 1);
	render_map(&game);
	mlx_hook(game.win_ptr, 2, 1L << 0, handle_keypress, &game);
	mlx_loop(game.mlx_ptr);
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/06 21:27:11 by shiori            #+#    #+#             */
/*   Updated: 2024/08/04 17:40:09 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

int	check_file_name(char *file_name)
{
	size_t	len;

	len = ft_strlen(file_name);
	if (len < 4 || ft_strncmp((file_name + len - 4), ".ber", 4) != 0)
	{
		ft_putstr_fd("Error\nWrong file extension\n", 2);
		return (1);
	}
	return (0);
}

int	count_map_size(char *filename, t_game *game)
{
	char	*line;
	int		fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		handle_error(game, "Failed to open file", 0);
	game->map->x = 0;
	game->map->y = 0;
	while (1)
	{
		line = get_next_line(fd);
		if (!line)
			break ;
		if (line[0] != '\n')
			game->map->y++;
		if (game->map->y == 1)
			game->map->x = ft_strlen(line) - 1;
		free(line);
	}
	close(fd);
	return (0);
}

int	validate_and_store_map(t_game *game, char *line, int *i)
{
	int	len;

	len = ft_strlen(line);
	if (line[len - 1] == '\n')
		len--;
	if (len != game->map->x)
		return (1);
	game->map->data[*i] = ft_strtrim(line, "\n");
	if (!game->map->data[*i])
		handle_error(game, "Failed map allocate process\n", 1);
	(*i)++;
	if (*i == game->map->y)
	{
		if (check_map_borders_and_contents(game->map))
			handle_error(game, "invalid map\n", 1);
	}
	return (0);
}

int	create_map(t_game *game, char *filename)
{
	int		fd;
	char	*line;
	int		i;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		handle_error(game, "Failed to open file\n", 1);
	i = 0;
	while (1)
	{
		line = get_next_line(fd);
		if (!line)
			break ;
		if (validate_and_store_map(game, line, &i))
			handle_error(game, "Failed map is not square\n", 1);
		free(line);
	}
	close(fd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_validation.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/21 19:47:46 by syonekur          #+#    #+#             */
/*   Updated: 2024/08/04 17:40:19 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	check_map_borders(t_map *map)
{
	int	x;
	int	y;

	y = 0;
	while (y < map->y)
	{
		x = 0;
		while (x < map->x)
		{
			if (((y == 0) || (x == 0) || (y == map->y - 1) || (x == map->x - 1))
				&& map->data[y][x] != '1')
			{
				ft_putstr_fd("Error\nMap borders must be covered by walls\n",
					2);
				return (1);
			}
			x++;
		}
		y++;
	}
	return (0);
}

int	check_map_contents(t_map *map, int *player_cnt, int *exit_cnt,
		int *collected)
{
	int	x;
	int	y;

	y = 0;
	while (y < map->y)
	{
		x = 0;
		while (x < map->x)
		{
			if (map->data[y][x] == 'P')
				(*player_cnt)++;
			else if (map->data[y][x] == 'E')
				(*exit_cnt)++;
			else if (map->data[y][x] == 'C')
				(*collected)++;
			else if (map->data[y][x] != '0' && map->data[y][x] != '1')
			{
				ft_putstr_fd("Error\nInvalid character in map\n", 2);
				return (1);
			}
			x++;
		}
		y++;
	}
	return (0);
}

int	check_map_borders_and_contents(t_map *map)
{
	int	player_cnt;
	int	exit_cnt;
	int	collected;

	player_cnt = 0;
	exit_cnt = 0;
	collected = 0;
	if (map == NULL || map->data == NULL)
	{
		ft_putstr_fd("Error\nMap or map data is NULL\n", 2);
		return (1);
	}
	if (check_map_borders(map) || check_map_contents(map, &player_cnt,
			&exit_cnt, &collected))
		return (1);
	if (player_cnt != 1 || exit_cnt != 1 || collected < 1)
	{
		ft_putstr_fd("Error\n", 2);
		ft_putstr_fd("Invalid number of players, exits, or collectibles\n", 2);
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/21 19:45:08 by syonekur          #+#    #+#             */
/*   Updated: 2024/08/03 22:55:20 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	allocate_visited_memory(t_game *game, char ***visited)
{
	int	y;

	*visited = malloc((game->map->y) * sizeof(char *));
	if (!*visited)
		return (1);
	y = 0;
	while (y < game->map->y)
	{
		(*visited)[y] = malloc((game->map->x + 1) * sizeof(char));
		if (!(*visited)[y])
		{
			free_double_pointer(*visited, y);
			return (1);
		}
		ft_memset((*visited)[y], '0', game->map->x + 1);
		y++;
	}
	return (0);
}

int	is_valid_path(t_game *game)
{
	char	**visited;
	int		exit_found;
	int		collectibles_found;
	int		y;

	visited = NULL;
	if (allocate_visited_memory(game, &visited))
		return (0);
	exit_found = (check_reachable_exit(game, game->player_x, game->player_y,
				visited));
	y = 0;
	while (y < game->map->y)
	{
		ft_memset(visited[y], '0', game->map->x);
		y++;
	}
	collectibles_found = count_reachable_collectibles(game, game->player_x,
			game->player_y, visited);
	free_double_pointer(visited, game->map->y);
	return (exit_found && collectibles_found == game->collectibles);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: syonekur <syonekur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/16 16:11:50 by shiori            #+#    #+#             */
/*   Updated: 2024/08/04 17:40:43 by syonekur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	free_double_pointer(char **ptr, int height)
{
	int	y;

	if (!ptr)
		return ;
	y = 0;
	while (y < height)
	{
		free(ptr[y]);
		y++;
	}
	free(ptr);
}

void	free_images(t_game *game)
{
	if (game->image_wall)
		mlx_destroy_image(game->mlx_ptr, game->image_wall);
	if (game->image_empty)
		mlx_destroy_image(game->mlx_ptr, game->image_empty);
	if (game->image_player)
		mlx_destroy_image(game->mlx_ptr, game->image_player);
	if (game->image_collectible)
		mlx_destroy_image(game->mlx_ptr, game->image_collectible);
	if (game->image_exit)
		mlx_destroy_image(game->mlx_ptr, game->image_exit);
}

void	free_map_window_display(t_game *game)
{
	if (game->map && game->map->data)
	{
		free_double_pointer(game->map->data, game->map->y);
		game->map->data = NULL;
	}
	if (game->map)
	{
		free(game->map);
		game->map = NULL;
	}
	if (game->win_ptr)
	{
		mlx_destroy_window(game->mlx_ptr, game->win_ptr);
		game->win_ptr = NULL;
	}
	if (game->mlx_ptr)
	{
		mlx_destroy_display(game->mlx_ptr);
		free(game->mlx_ptr);
		game->mlx_ptr = NULL;
	}
}

void	free_resources(t_game *game)
{
	free_images(game);
	free_map_window_display(game);
}
